#pragma kernel CalculatePredictedParticlePositions
#pragma kernel CalculateCellKeys
#pragma kernel ReorderToTemp
#pragma kernel CommitReorder
#pragma kernel CalculateDensities
#pragma kernel CalculatePressureForces
#pragma kernel CalculateInteractionForces
#pragma kernel UpdateVelocities
#pragma kernel UpdatePositions
#pragma kernel GenerateCanvasTexture

#include "./SmoothingFunctions.hlsl"
#include "./SpatialPartitioning.hlsl"

struct Particle {
    float2 position;
    float2 velocity;
};

uint particleCount;
RWStructuredBuffer<Particle> particleBuffer;
RWStructuredBuffer<float2> predictedParticlePositionBuffer;

RWStructuredBuffer<Particle> tempParticleBuffer;
RWStructuredBuffer<float2> tempPredictedParticlePositionBuffer;

RWStructuredBuffer<uint> cellKeyBuffer;
RWStructuredBuffer<uint> startIndexBuffer;
StructuredBuffer<uint> sortedIndexBuffer;

RWStructuredBuffer<float> densityBuffer;
RWStructuredBuffer<float2> pressureForceBuffer;
RWStructuredBuffer<float2> interactionForceBuffer;
RWTexture2D<float4> canvasRenderTexture;
float deltaTime;
float smoothingRadius;
float collisionDamping;
float pressureMultiplier;
float densityBrightnessMultiplier;
float2 boundsSize;
int2 canvasResolution;
float2 interactionPosition;
float interactionStrength;
float interactionRadius;
bool isPullInteraction;
bool isPushInteraction;

float Map(float value, float fromMin, float fromMax, float toMin, float toMax)
{
    return toMin + (value - fromMin) * (toMax - toMin) / (fromMax - fromMin);
}

float SmoothingKernel(float radius, float distance)
{
    if (distance >= radius)
        return 0.0;

    return SpikyPow2Kernel(radius, distance);
}

float SmoothingKernelDerivative(float radius, float distance)
{
    if (distance >= radius)
        return 0.0;

    return SpikyPow2KernelDerivative(radius, distance);
}

void HandleBoundaryCollisions(int particleI)
{
    float2 halfBoundsSize = boundsSize * 0.5;
    Particle particle = particleBuffer[particleI];

    if (particle.position.x <= -halfBoundsSize.x) {
        particle.position.x = -halfBoundsSize.x;
        particle.velocity.x *= -1 * collisionDamping;
    }

    if (particle.position.x >= halfBoundsSize.x) {
        particle.position.x = halfBoundsSize.x;
        particle.velocity.x *= -1 * collisionDamping;
    }

    if (particle.position.y <= -halfBoundsSize.y) {
        particle.position.y = -halfBoundsSize.y;
        particle.velocity.y *= -1 * collisionDamping;
    }

    if (particle.position.y >= halfBoundsSize.y) {
        particle.position.y = halfBoundsSize.y;
        particle.velocity.y *= -1 * collisionDamping;
    }

    particleBuffer[particleI] = particle;
}

void HandleCollisions(int particleI)
{
    HandleBoundaryCollisions(particleI);
}

float calculateDensity(float2 position)
{
    float density = 0;
    float smoothingRadiusSquared = smoothingRadius * smoothingRadius;

    int2 positionCellCoordinates = GetCellCoordinates(position, smoothingRadius);

    for (int cellOffsetI = 0; cellOffsetI < 9; cellOffsetI++){
        int2 offsetCellCoordinates = positionCellCoordinates + CELL_OFFSETS[cellOffsetI];
        uint offsetCellHash = GetCellHash(offsetCellCoordinates);
        uint offsetCellKey = GetCellKeyFromHash(offsetCellHash, particleCount);
        uint currentParticleI = startIndexBuffer[offsetCellKey];

        while(currentParticleI < particleCount){
            uint otherParticleI = currentParticleI;
            currentParticleI++;

            uint otherParticleCellKey = cellKeyBuffer[otherParticleI];
            if (otherParticleCellKey != offsetCellKey) break;

            float2 otherParticlePosition = predictedParticlePositionBuffer[otherParticleI];

            float2 positionDelta = otherParticlePosition - position;
            float distanceSquared = dot(positionDelta, positionDelta);

            if(distanceSquared >= smoothingRadiusSquared) continue;

            float distance = sqrt(distanceSquared);
            density += SmoothingKernel(smoothingRadius, distance);
        }
    }

    return density;
}

[numthreads(256, 1, 1)]
void CalculatePredictedParticlePositions(uint3 id : SV_DispatchThreadID)
{
    uint particleI = id.x;
    if (particleI >= particleCount) return;

    Particle particle = particleBuffer[particleI];
    float2 predictedPosition = particle.position + particle.velocity * 1.0 / 120.0;
    predictedParticlePositionBuffer[particleI] = predictedPosition;
}

[numthreads(256, 1, 1)]
void CalculateCellKeys(uint3 id : SV_DispatchThreadID)
{
    uint particleI = id.x;
    if (particleI >= particleCount) return;

    Particle particle = particleBuffer[particleI];
    float2 position = particle.position;
    int2 cellCoordinates = GetCellCoordinates(position, smoothingRadius);
    uint cellHash = GetCellHash(cellCoordinates);
    uint cellKey = GetCellKeyFromHash(cellHash, particleCount);
    cellKeyBuffer[particleI] = cellKey;
}

[numthreads(256, 1, 1)]
void ReorderToTemp(uint3 id : SV_DispatchThreadID)
{
    uint particleI = id.x;
    if (particleI >= particleCount) return;

    uint sortedIndex = sortedIndexBuffer[particleI];
    tempParticleBuffer[particleI] = particleBuffer[sortedIndex];
    tempPredictedParticlePositionBuffer[particleI] = predictedParticlePositionBuffer[sortedIndex];
}

[numthreads(256, 1, 1)]
void CommitReorder(uint3 id : SV_DispatchThreadID)
{
    uint particleI = id.x;
    if (particleI >= particleCount) return;

    particleBuffer[particleI] = tempParticleBuffer[particleI];
    predictedParticlePositionBuffer[particleI] = tempPredictedParticlePositionBuffer[particleI];
}

[numthreads(256, 1, 1)]
void CalculateDensities(uint3 id : SV_DispatchThreadID)
{
    uint selfParticleI = id.x;
    if (selfParticleI >= particleCount) return;

    float2 selfParticlePredictedPosition = predictedParticlePositionBuffer[selfParticleI];

    densityBuffer[selfParticleI] = calculateDensity(selfParticlePredictedPosition);
}

[numthreads(256, 1, 1)]
void CalculatePressureForces(uint3 id : SV_DispatchThreadID)
{
    uint selfParticleI = id.x;
    if (selfParticleI >= particleCount) return;

    float2 pressureForce = float2(0.0, 0.0);
    float2 selfParticlePredictedPosition = predictedParticlePositionBuffer[selfParticleI];
    float smoothingRadiusSquared = smoothingRadius * smoothingRadius;

    int2 positionCellCoordinates = GetCellCoordinates(selfParticlePredictedPosition, smoothingRadius);
    for (int cellOffsetI = 0; cellOffsetI < 9; cellOffsetI++){
        int2 offsetCellCoordinates = positionCellCoordinates + CELL_OFFSETS[cellOffsetI];
        uint offsetCellHash = GetCellHash(offsetCellCoordinates);
        uint offsetCellKey = GetCellKeyFromHash(offsetCellHash, particleCount);
        uint currentParticleI = startIndexBuffer[offsetCellKey];

        while(currentParticleI < particleCount){
            uint otherParticleI = currentParticleI;
            currentParticleI++;

            if (otherParticleI == selfParticleI) continue;

            uint otherParticleCellKey = cellKeyBuffer[otherParticleI];
            if (otherParticleCellKey != offsetCellKey) break;

            float2 otherParticlePredictedPosition = predictedParticlePositionBuffer[otherParticleI];
            float2 positionDelta = otherParticlePredictedPosition - selfParticlePredictedPosition;
            float distanceSquared = dot(positionDelta, positionDelta);

            if(distanceSquared >= smoothingRadiusSquared) continue;

            float distance = sqrt(distanceSquared);
            float2 positionDeltaNormalized = distance > 0 ? positionDelta / distance : float2(0.0, 1.0);
            pressureForce += positionDeltaNormalized * SmoothingKernelDerivative(smoothingRadius, distance) / densityBuffer[otherParticleI];
        }
    }

    pressureForceBuffer[selfParticleI] = pressureForce * pressureMultiplier;
}

[numthreads(256, 1, 1)]
void CalculateInteractionForces(uint3 id : SV_DispatchThreadID)
{
    uint particleI = id.x;
    if (particleI >= particleCount) return;

    if (!isPullInteraction && !isPushInteraction) {
        interactionForceBuffer[particleI] = float2(0.0, 0.0);
        return;
    }

    float2 predictedParticlePosition = predictedParticlePositionBuffer[particleI];
    float2 positionDelta = interactionPosition - predictedParticlePosition;
    float distanceSquared = dot(positionDelta, positionDelta);

    if (distanceSquared < interactionRadius * interactionRadius) {
        float distance = sqrt(distanceSquared);
        float ratioToCenter = distance / interactionRadius;
        float ratioToEdge = 1 - ratioToCenter;
        float2 directionToCenter = positionDelta / distance;

        float2 interactionForce = directionToCenter * ratioToEdge * interactionStrength;
        interactionForce -= particleBuffer[particleI].velocity;
        if (isPullInteraction) {
            interactionForce *= -1;
        }
        interactionForceBuffer[particleI] = interactionForce;
    }
}

[numthreads(256, 1, 1)]
void UpdateVelocities(uint3 id : SV_DispatchThreadID)
{
    uint particleI = id.x;
    if (particleI >= particleCount) return;

    Particle particle = particleBuffer[particleI];

    float2 pressureForce = pressureForceBuffer[particleI];
    float2 pressureAcceleration = pressureForce / densityBuffer[particleI];
    particle.velocity += pressureAcceleration * deltaTime;

    float2 interactionForce = interactionForceBuffer[particleI];
    float2 interactionAcceleration = interactionForce / densityBuffer[particleI];
    particle.velocity += interactionAcceleration * deltaTime;

    particleBuffer[particleI] = particle;
}

[numthreads(256, 1, 1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID)
{
    uint particleI = id.x;
    if (particleI >= particleCount) return;

    Particle particle = particleBuffer[particleI];
    particle.position += particle.velocity * deltaTime;
    particleBuffer[particleI] = particle;
    HandleCollisions(particleI);
}

[numthreads(8, 8, 1)]
void GenerateCanvasTexture(uint3 id : SV_DispatchThreadID)
{
    uint pixelX = id.x;
    uint pixelY = id.y;
    int canvasResolutionX = canvasResolution.x;
    int canvasResolutionY = canvasResolution.y;
    float worldX = Map(pixelX, 0.0, canvasResolutionX, -19.2 / 2.0, 19.2 / 2.0);
    float worldY = Map(pixelY, 0.0, canvasResolutionY, -10.8 / 2.0, 10.8 / 2.0);
    float2 worldPosition = float2(worldX, worldY);

    float totalDensity = calculateDensity(worldPosition);

    float pixelBrightness = totalDensity * densityBrightnessMultiplier;
    canvasRenderTexture[id.xy] = float4(pixelBrightness, pixelBrightness, pixelBrightness, 0.0);
}
