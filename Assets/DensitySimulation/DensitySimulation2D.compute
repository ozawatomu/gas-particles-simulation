#pragma kernel CalculateDensities
#pragma kernel CalculatePressureForces
#pragma kernel CalculateInteractionForces
#pragma kernel UpdateVelocities
#pragma kernel UpdatePositions
#pragma kernel GenerateCanvasTexture
#pragma kernel CalculatePredictedParticlePositions

struct Particle {
    float2 position;
    float2 velocity;
};

int particleCount;
RWStructuredBuffer<Particle> particleBuffer;
RWStructuredBuffer<float2> predictedParticlePositionBuffer;
RWStructuredBuffer<float> densityBuffer;
RWStructuredBuffer<float2> pressureForceBuffer;
RWStructuredBuffer<float2> interactionForceBuffer;
RWTexture2D<float4> canvasRenderTexture;
float deltaTime;
float smoothingRadius;
float collisionDamping;
float pressureMultiplier;
float densityBrightnessMultiplier;
float2 boundsSize;
int2 canvasResolution;
float2 interactionPosition;
float interactionStrength;
float interactionRadius;
bool isInteraction;

float Map(float value, float fromMin, float fromMax, float toMin, float toMax)
{
    return toMin + (value - fromMin) * (toMax - toMin) / (fromMax - fromMin);
}

float SmoothingKernel(float radius, float distance)
{
    if (distance >= radius)
        return 0.0;

    float volume = 3.14159265359 * pow(radius, 5.0) / 10.0;
    float value = radius - distance;
    return (value * value * value) / volume;
}

float SmoothingKernelDerivative(float radius, float distance)
{
    if (distance >= radius)
        return 0.0;

    return -(30.0 / (3.14159265 * pow(radius, 5))) * pow(radius - distance, 2);
}

void HandleBoundaryCollisions(int particleI)
{
    float2 halfBoundsSize = boundsSize * 0.5;
    Particle particle = particleBuffer[particleI];

    if (particle.position.x <= -halfBoundsSize.x) {
        particle.position.x = -halfBoundsSize.x;
        particle.velocity.x *= -1 * collisionDamping;
    }

    if (particle.position.x >= halfBoundsSize.x) {
        particle.position.x = halfBoundsSize.x;
        particle.velocity.x *= -1 * collisionDamping;
    }

    if (particle.position.y <= -halfBoundsSize.y) {
        particle.position.y = -halfBoundsSize.y;
        particle.velocity.y *= -1 * collisionDamping;
    }

    if (particle.position.y >= halfBoundsSize.y) {
        particle.position.y = halfBoundsSize.y;
        particle.velocity.y *= -1 * collisionDamping;
    }

    particleBuffer[particleI] = particle;
}

void HandleCollisions(int particleI)
{
    HandleBoundaryCollisions(particleI);
}

[numthreads(256, 1, 1)]
void CalculatePredictedParticlePositions(uint3 id : SV_DispatchThreadID)
{
    int particleI = id.x;
    if (particleI >= particleCount) return;

    Particle particle = particleBuffer[particleI];
    float2 predictedPosition = particle.position + particle.velocity * 1.0 / 120.0;
    predictedParticlePositionBuffer[particleI] = predictedPosition;
}

[numthreads(256, 1, 1)]
void CalculateDensities(uint3 id : SV_DispatchThreadID)
{
    int selfParticleI = id.x;
    if (selfParticleI >= particleCount) return;

    float2 selfParticlePredictedPosition = predictedParticlePositionBuffer[selfParticleI];
    float density = 0;
    float smoothingRadiusSquared = smoothingRadius * smoothingRadius;

    for (int otherParticleI = 0; otherParticleI < particleCount; otherParticleI++) {
        float2 otherParticlePredictedPosition = predictedParticlePositionBuffer[otherParticleI];
        float2 positionDelta = otherParticlePredictedPosition - selfParticlePredictedPosition;
        float distanceSquared = dot(positionDelta, positionDelta);

        if (distanceSquared < smoothingRadiusSquared) {
            float distance = sqrt(distanceSquared);
            density += SmoothingKernel(smoothingRadius, distance);
        }
    }

    densityBuffer[selfParticleI] = density;
}

[numthreads(256, 1, 1)]
void CalculatePressureForces(uint3 id : SV_DispatchThreadID)
{
    int selfParticleI = id.x;
    if (selfParticleI >= particleCount) return;

    float2 pressureForce = float2(0.0, 0.0);
    float2 selfParticlePredictedPosition = predictedParticlePositionBuffer[selfParticleI];
    float smoothingRadiusSquared = smoothingRadius * smoothingRadius;

    for (int otherParticleI = 0; otherParticleI < particleCount; otherParticleI++) {
        if (otherParticleI == selfParticleI) continue;

        float2 otherParticlePredictedPosition = predictedParticlePositionBuffer[otherParticleI];
        float2 positionDelta = otherParticlePredictedPosition - selfParticlePredictedPosition;
        float distanceSquared = dot(positionDelta, positionDelta);

        if (distanceSquared < smoothingRadiusSquared) {
            float distance = sqrt(distanceSquared);
            float2 positionDeltaNormalized = positionDelta / distance;
            pressureForce += positionDeltaNormalized * SmoothingKernelDerivative(smoothingRadius, distance) / densityBuffer[otherParticleI];
        }
    }

    pressureForceBuffer[selfParticleI] = pressureForce * pressureMultiplier;
}

[numthreads(256, 1, 1)]
void CalculateInteractionForces(uint3 id : SV_DispatchThreadID)
{
    int particleI = id.x;
    if (particleI >= particleCount) return;

    if (!isInteraction) {
        interactionForceBuffer[particleI] = float2(0.0, 0.0);
        return;
    }

    float2 predictedParticlePosition = predictedParticlePositionBuffer[particleI];
    float2 positionDelta = interactionPosition - predictedParticlePosition;
    float distanceSquared = dot(positionDelta, positionDelta);

    if (distanceSquared < interactionRadius * interactionRadius) {
        float distance = sqrt(distanceSquared);
        float ratioToCenter = distance / interactionRadius;
        float ratioToEdge = 1 - ratioToCenter;
        float2 directionToCenter = positionDelta / distance;

        float2 interactionForce = directionToCenter * ratioToEdge * interactionStrength;
        interactionForce -= particleBuffer[particleI].velocity;
        interactionForceBuffer[particleI] = -interactionForce;
    }
}

[numthreads(256, 1, 1)]
void UpdateVelocities(uint3 id : SV_DispatchThreadID)
{
    int particleI = id.x;
    if (particleI >= particleCount) return;

    Particle particle = particleBuffer[particleI];

    float2 pressureForce = pressureForceBuffer[particleI];
    float2 pressureAcceleration = pressureForce / densityBuffer[particleI];
    particle.velocity += pressureAcceleration * deltaTime;

    float2 interactionForce = interactionForceBuffer[particleI];
    float2 interactionAcceleration = interactionForce / densityBuffer[particleI];
    particle.velocity += interactionAcceleration * deltaTime;

    particleBuffer[particleI] = particle;
}

[numthreads(256, 1, 1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID)
{
    int particleI = id.x;
    if (particleI >= particleCount) return;

    Particle particle = particleBuffer[particleI];
    particle.position += particle.velocity * deltaTime;
    particleBuffer[particleI] = particle;
    HandleCollisions(particleI);
}

[numthreads(8, 8, 1)]
void GenerateCanvasTexture(uint3 id : SV_DispatchThreadID)
{
    int pixelX = id.x;
    int pixelY = id.y;
    int canvasResolutionX = canvasResolution.x;
    int canvasResolutionY = canvasResolution.y;
    float worldX = Map(pixelX, 0.0, canvasResolutionX, -19.2 / 2.0, 19.2 / 2.0);
    float worldY = Map(pixelY, 0.0, canvasResolutionY, -10.8 / 2.0, 10.8 / 2.0);
    float2 worldPosition = float2(worldX, worldY);

    float totalDensity = 0.0;
    for (int particleI = 0; particleI < particleCount; particleI++) {
        Particle particle = particleBuffer[particleI];
        float2 particlePosition = particle.position;
        float2 positionDelta = particlePosition - worldPosition;
        float distanceSquared = dot(positionDelta, positionDelta);
        float distance = sqrt(distanceSquared);

        if (distance < smoothingRadius) {
            totalDensity += SmoothingKernel(smoothingRadius, distance);
        }
    }

    float pixelBrightness = totalDensity * densityBrightnessMultiplier;
    canvasRenderTexture[id.xy] = float4(pixelBrightness, pixelBrightness, pixelBrightness, 0.0);
}
