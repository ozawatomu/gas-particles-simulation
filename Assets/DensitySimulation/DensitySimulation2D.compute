#pragma kernel CalculateDensities
#pragma kernel CalculatePressureForces
#pragma kernel UpdateVelocities
#pragma kernel UpdatePositions
#pragma kernel GenerateCanvasTexture

struct Particle {
    float2 position;
    float2 velocity;
};

int particleCount;
RWStructuredBuffer<Particle> particleBuffer;
RWStructuredBuffer<float> densityBuffer;
RWStructuredBuffer<float2> pressureForceBuffer;
RWTexture2D<float4> canvasRenderTexture;
float deltaTime;
float smoothingRadius;
float densityBrightnessMultiplier;
float2 boundsSize;
int2 canvasResolution;

float Map(float value, float fromMin, float fromMax, float toMin, float toMax)
{
    return toMin + (value - fromMin) * (toMax - toMin) / (fromMax - fromMin);
}

float SmoothingKernel(float radius, float distance)
{
    if (distance >= radius)
        return 0.0;

    float volume = 3.14159265359 * pow(radius, 5.0) / 10.0;
    float value = radius - distance;
    return (value * value * value) / volume;
}

float SmoothingKernelDerivative(float radius, float distance)
{
    if (distance >= radius)
        return 0.0;

    if (distance >= 0.0 && distance < radius)
        return -3.0 * pow(radius - distance, 2.0);

    return 3.0 * pow(radius + distance, 2.0);
}

void HandleBoundaryCollisions(int particleI)
{
    float2 halfBoundsSize = boundsSize * 0.5;

    Particle particle = particleBuffer[particleI];
    if (particle.position.x <= -halfBoundsSize.x) {
        particle.position.x = -halfBoundsSize.x;
        particle.velocity.x *= -1;
    }

    if (particle.position.x >= halfBoundsSize.x) {
        particle.position.x = halfBoundsSize.x;
        particle.velocity.x *= -1;
    }

    if (particle.position.y <= -halfBoundsSize.y) {
        particle.position.y = -halfBoundsSize.y;
        particle.velocity.y *= -1;
    }

    if (particle.position.y >= halfBoundsSize.y) {
        particle.position.y = halfBoundsSize.y;
        particle.velocity.y *= -1;
    }

    particleBuffer[particleI] = particle;
}

void HandleCollisions(int particleI)
{
    HandleBoundaryCollisions(particleI);
}

[numthreads(256, 1, 1)]
void CalculateDensities(uint3 id : SV_DispatchThreadID)
{
    int selfParticleI = id.x;
    if (selfParticleI >= particleCount) return;

    Particle selfParticle = particleBuffer[selfParticleI];
    float density = 0;
    float smoothingRadiusSquared = smoothingRadius * smoothingRadius;

    for (int otherParticleI = 0; otherParticleI < particleCount; otherParticleI++)
    {
        Particle otherParticle = particleBuffer[otherParticleI];
        float2 positionDelta = otherParticle.position - selfParticle.position;
        float distanceSquared = dot(positionDelta, positionDelta);

        if (distanceSquared < smoothingRadiusSquared)
        {
            float distance = sqrt(distanceSquared);
            density += SmoothingKernel(smoothingRadius, distance);
        }
    }

    densityBuffer[selfParticleI] = density;
}

[numthreads(256, 1, 1)]
void CalculatePressureForces(uint3 id : SV_DispatchThreadID)
{
    int selfParticleI = id.x;
    if (selfParticleI >= particleCount) return;

    float2 pressureForce = float2(0.0, 0.0);
    Particle selfParticle = particleBuffer[selfParticleI];
    float smoothingRadiusSquared = smoothingRadius * smoothingRadius;

    for (int otherParticleI = 0; otherParticleI < particleCount; otherParticleI++)
    {
        if (otherParticleI == selfParticleI) continue;

        Particle otherParticle = particleBuffer[otherParticleI];
        float2 positionDelta = otherParticle.position - selfParticle.position;
        float distanceSquared = dot(positionDelta, positionDelta);

        if (distanceSquared < smoothingRadiusSquared)
        {
            float distance = sqrt(distanceSquared);
            float2 positionDeltaNormalized = positionDelta / distance;
            pressureForce += positionDeltaNormalized * SmoothingKernelDerivative(smoothingRadius, distance) / densityBuffer[otherParticleI];
        }
    }

    pressureForceBuffer[selfParticleI] = pressureForce;
}

[numthreads(256, 1, 1)]
void UpdateVelocities(uint3 id : SV_DispatchThreadID)
{
    int particleI = id.x;
    if (particleI >= particleCount) return;

    Particle particle = particleBuffer[particleI];
    float2 pressureForce = pressureForceBuffer[particleI];
    particle.velocity += pressureForce * deltaTime;
    particleBuffer[particleI] = particle;
}

[numthreads(256, 1, 1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID)
{
    int particleI = id.x;
    if (particleI >= particleCount) return;

    Particle particle = particleBuffer[particleI];
    particle.position += particle.velocity * deltaTime;
    particleBuffer[particleI] = particle;
    HandleCollisions(particleI);
}

[numthreads(8, 8, 1)]
void GenerateCanvasTexture(uint3 id : SV_DispatchThreadID)
{
    int pixelX = id.x;
    int pixelY = id.y;
    int canvasResolutionX = canvasResolution.x;
    int canvasResolutionY = canvasResolution.y;
    float worldX = Map(pixelX, 0.0, canvasResolutionX, -19.2/2.0, 19.2/2.0);
    float worldY = Map(pixelY, 0.0, canvasResolutionY, -10.8/2.0, 10.8/2.0);
    float2 worldPosition = float2(worldX, worldY);

    float totalDensity = 0.0;
    for(int particleI = 0; particleI < particleCount; particleI++){
        Particle particle = particleBuffer[particleI];
        float2 particlePosition = particle.position;
        float2 positionDelta = particlePosition - worldPosition;
        float distanceSquared = dot(positionDelta, positionDelta);
        float distance = sqrt(distanceSquared);
        if(distance < smoothingRadius){
            totalDensity = totalDensity + SmoothingKernel(smoothingRadius, distance);
        }
    };

    float pixelBrightness = totalDensity * densityBrightnessMultiplier;

    canvasRenderTexture[id.xy] = float4(pixelBrightness, pixelBrightness, pixelBrightness, 0.0);
}
